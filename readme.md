# Arduino pro micro - записки исследователя

[Arduino pro micro](http://www.pighixxx.com/test/2016/07/pro-micro-pinout/) - аналог arduino на чипе ATmega32U4, идентифицируется как "Arduino Leonardo". При заказе мне чертовски повезло, хотел брать "arduino pro mini" но ее не оказалось и выбор пал на эту модель. Как выяснилось позже - это единственный чип который официально может делать вывод через USB как HID устройство (эмуляция клавиатуры и мыши, для других плат потребуется танцы с бубнами).

![Распиновка](/images/pro_micro_pinout_v1_0_blue1.png)

Критерии выбора были:
1. Цена. В лом было платить 1000 рублей за неведомо что. Итого: 325 рублей а Амперкоте.
2. Наличие USB порта. Выяснилось, что есть модели без USB, для прошивки которых потребуется программатор.
3. Наличие впаянных ножек. К сожалению для arduino pro micro ножки прилагались отдельно, они небыли припаяны, пришлось паять самому...

Также были заказаны:
1. Монтажная палата.
2. Набор соединительных проводов разных типов (как показала практика проводки папа-папа востребованы более всего, их стоит брать побольше).
3. Пульт ДУ.
4. Кнопочки разных цветов - 3 штуки.
5. Модуль для чтения RFID меток - такие чипы в виде спиральки которые вклеивают в книги, одежу и т.п. в магазинах чтобы не сперли чего, также RFID использует мосгортранс в билетиках, но главная тема ради чего все это мутится, аутентификация компьютера (ввод пароля) от брелока (прилагается к модулю) или от карты. Именно тут понадобится особенность чипа ATmega32U4 работать как HID устройство, то есть приложили брелок оно напечатало пароль.

Позже оказалось, что неплохо было бы закупить:
1. Резисторы на 10кОм для подключения кнопок (можно и без них, но рекомендуют).
2. Резисторы на 220Ом для подключения светодиодов.
3. Светодиоды чтобы моргать, хотя имеются встроенные, так что можно и без них.

# Подключение #

Обычным микро usb кабелем подключаем к компьютеру. Windows брякает и определяет ее как "Arduino Leonardo" (в диспетчере устройств раздел "Порты COM и LPT")

Ставим [Arduino IDE](https://www.arduino.cc/en/main/software)

В меню "Инструменты" выбираем "Arduino Leonardo" и порт нашей платы. Порт может изменится. В случае изменения порта, порт надо выбрать заново вручную.

После этого все готово к загрузке программ.

# blink - моргаем встроенными светодиодами

В классической Arduino встроенный светодиод расположен на пине 13 и им можно моргать, для чего есть классический пример под названием blink входящий в состав Arduino IDE. В ATmega32U4 такого светодиода нет, и стандартный пример blink работать не будет. Зато имеются два светодиода служащими индикаторами для процессов чтения записи RX и TX. Они расположены на пинах 17 (RX) и 30 (TX), так что пришлось написать свой пример моргающий этими светодиодами.

Также добавим функционал моргания внешним светодиодом подключенным по классической схеме на пин 2. В схеме используется резистор 220Ом. В маем случае зеленый светодиод на 3 вольта и резистор на 200Ом работают нормально.

![GitHub Logo](/images/led_bb.png)

По какой то, видимо технологической причине, включение и выключение встроенных светодиодов инвертировано и значение LOW включает светодиод а значение HIGH выключает. В случае с внешним светодиодом все наоборот, так как и должно быть.

Код примера: [blink](/blink)

# button - подключаем кнопку

Пример прост - нажали на кнопку загорелся встроенный светодиод, отпустили потух.

Оказалось, есть несколько методов подключения кнопки.
1. Через резистор на 10 кОм. Резистор используется для стабилизации нулевого сигнала (кнопка отжата), так как на пин могут влиять наводки из вне, что может привести к спонтанному срабатыванию.
2. Через встроенный резистор. Значение пина инвертировано, то есть при нажатии LOW при отпускании HIGH.
3. Сложная схема позволяющая избежать эффекта дребезга кнопки при срабатывании. Такое происходит когда контакт смыкается и размыкается, действие механическое и может коротнуть лишний раз, что может привести к ложным срабатываниям. Происходит это считанные доли секунды но Arduino достаточно быстра чтобы среагировать. Избежать подобного также можно установив задержку после нажатия клавиши на 5-10 миллисекунд, (возможно меньше, зависит от ситуации).

В связи с тем, что перед покупкой я ничего не знал про резистор на 10 кОм, я его естественно не купил. Потом, я тупанул и купил резисторов на 10 Ом =) В общем жизнь заставила углубиться в тему и узнать про встроенный резистор, и подключении кнопки напрямую.

![Схема подключения кнопки напрямую](/images/button_direct_bb.png)

Меня как перфекциониста немного бомбит идея обновлять состояние пина каждую итерацию цикла, по этому в коде я решил отслеживать изменение пина кнопки и изменять состояние светодиода только в случае если изменилось значение на пине кнопки. Для этого введены переменные ledState и buttonState.

Код примера: [button](/button)

# type - работаем как клавиатура

Итак, теперь когда есть кнопка пришло время научить ее делать нечто полезное. Выше я уже писал про то, что ATmega32U4 умеет посылать сигналы HID через USB, иначе говоря работать как клавиатура, мышь или джойстик. Настало время протестировать эту способность, будем жать кнопку 'x'.

В комплекте Arduino IDE есть библиотека Keyboard.h используя которую мы может отправлять коды клавиш на USB. У либы есть минусы, она не умеет мультимедия клавиши (vol+, vol-, калькулятор и т.п.) С другой стороны, позволяет отправить любой ASCII символ и спец клавиши PageUp, PageDown, F1, F2 и т.п., позволяет задавать модификаторы - зажатый Shift, Ctrl и т.п. Для более продвинутых операций видимо нужно писать свое либо искать в интернетах, беглый анализ показал, что Keyboard.h работает через Usb.h, но там довольно запутанная система подготовки кодов и идентификации устройства в которой я пока разбираться не стал, для обычных целей библиотеки хватит за глаза.

Удалось выяснить забавную штуку, клавиатура совместимая с HID посылает бит говорящий о том - раскладку какой страны она использует, что может указать на вражеского шпиона либо раскрыть нашего разведчика в тылу врага.

Код примера: [type](/type)

# remote - пульт управления

В комплектации пульта был пульт, диод приемник, платка для диода приемника с красным светодиодом который светиться постоянно при подключении и проводки мама-мама три штуки. Проводки для монтажной платы оказались бесполезными, так как надо мама-папа либо папа-папа. Платка имела шесть штырьков которые попарно дублировали друг друга. Зачем, ума не приложу. По сути платка необязательна, диод можно воткнуть в монтажную плату, будет работать. Контакты на плате подключены на прямую, микросхем нет, пара резисторов для светодиода и все.

Подключение простое, без дополнительных деталей, земля (GND), питание (VCC) и данные (IN). GND и VCC к соответствующим пинам адруины, IN к желаемому пину данных.

![remote](/images/remote_bb.png)

Для работы с пультом я использовал библиотеку IRremote.h которую пришлой доставить через менеджер библиотек.

Пульт работает уверенно, другие пульты тоже принимает, так что в теории хватило бы и диода
приемника.

Коды кнопок моего пульта:

```
#define REMOTE_BUTTON_00 0xE318261B // CH-
#define REMOTE_BUTTON_01 0x00511DBB // CH
#define REMOTE_BUTTON_02 0xEE886D7F // CH+
#define REMOTE_BUTTON_03 0x52A3D41F // prev
#define REMOTE_BUTTON_04 0xD7E84B1B // next
#define REMOTE_BUTTON_05 0x20FE4DBB // play
#define REMOTE_BUTTON_06 0xF076C13B // vol -
#define REMOTE_BUTTON_07 0xA3C8EDDB // vol +
#define REMOTE_BUTTON_08 0xE5CFBD7F // eq
#define REMOTE_BUTTON_09 0xC101E57B // 0
#define REMOTE_BUTTON_10 0x97483BFB // 100+
#define REMOTE_BUTTON_11 0xF0C41643 // 200+
#define REMOTE_BUTTON_12 0x9716BE3F // 1
#define REMOTE_BUTTON_13 0x3D9AE3F7 // 2
#define REMOTE_BUTTON_14 0x6182021B // 3
#define REMOTE_BUTTON_15 0x8C22657B // 4
#define REMOTE_BUTTON_16 0x488F3CBB // 5
#define REMOTE_BUTTON_17 0x0449E79F // 6
#define REMOTE_BUTTON_18 0x32C6FDF7 // 7
#define REMOTE_BUTTON_19 0x1BC0157B // 8
#define REMOTE_BUTTON_20 0x3EC3FC1B // 9
```

Код примера: [remote](/remote)

# rfid - радио метка

RFID (Radio Frequency IDentification) - способ автоматической идентификации объектов, в котором посредством радиосигналов считываются или записываются данные, хранящиеся в так называемых транспондерах, или RFID-метках.

Мне достался ридер MFRC-522, судя по всему один из самых популярных ридеров в среде Arduino. В наборе была карата, брелок, ридер и линейки с штырьками. Метки также бывают в виде браслета, тонких пленочек, колец и т.п. Кстати, билетики на метро тоже RFID метки.

## Подключение

Подключение MFRC-522 не требует дополнительных деталей (резисторы, конденсаторы и т.п.). Используется стандарт SDI, в (git проекта)[https://github.com/miguelbalboa/rfid] есть табличка где расписано, что к каким пинам надо подключать.

Пины расписаны не все, думаю автор посчитал, что вам будет не сложно догадаться куда должны идти GND и 3.3V. IRQ не идет некуда.

У меня затруднение вызвал только RST, так как в примерах он задефайнен на 9, а по таблице подключается к RESET. Но пин судя по всему не особо важный, так как и так и так у меня работает, хотя в последней редакции схемы я подключил его к пину 9.

+-----------+----------+---------------------------------------------------------------+--------------------------+
|           | PCD      | Arduino                                                       | Teensy                   |
|           +----------+-------------+---------+---------+-----------------+-----------+--------+--------+--------+
|           | MFRC522  | Uno / 101   | Mega    | Nano v3 |Leonardo / Micro | Pro Micro | 2.0    | ++ 2.0 | 3.1    |
+-----------+----------+-------------+---------+---------+-----------------+-----------+--------+--------+--------+
| Signal    | Pin      | Pin         | Pin     | Pin     | Pin             | Pin       | Pin    | Pin    | Pin    |
+===========+==========+=============+=========+=========+=================+===========+========+========+========+
| RST/Reset | RST      | 9 [1]_      | 5 [1]_  | D9      | RESET / ICSP-5  | RST       | 7      | 4      | 9      |
+-----------+----------+-------------+---------+---------+-----------------+-----------+--------+--------+--------+
| SPI SS    | SDA [3]_ | 10 [2]_     | 53 [2]_ | D10     | 10              | 10        | 0      | 20     | 10     |
+-----------+----------+-------------+---------+---------+-----------------+-----------+--------+--------+--------+
| SPI MOSI  | MOSI     | 11 / ICSP-4 | 51      | D11     | ICSP-4          | 16        | 2      | 22     | 11     |
+-----------+----------+-------------+---------+---------+-----------------+-----------+--------+--------+--------+
| SPI MISO  | MISO     | 12 / ICSP-1 | 50      | D12     | ICSP-1          | 14        | 3      | 23     | 12     |
+-----------+----------+-------------+---------+---------+-----------------+-----------+--------+--------+--------+
| SPI SCK   | SCK      | 13 / ICSP-3 | 52      | D13     | ICSP-3          | 15        | 1      | 21     | 13     |
+-----------+----------+-------------+---------+---------+-----------------+-----------+--------+--------+--------+

## Структура памяти

Память RFID метки разделена на сектора по 64 байта.
Каждый сектор разделен на блоки по 16 байт.
Первый три блока сектора хранят пользовательские данные.
Четвертый блок сектора хранит информацию о правах доступа - два ключа A и B и биты доступа которые описывают права доступа к данным для ключей. Обычно этот блок называют trail.

Для карт объемом выше 4Кб сектора за переделами отметки 2Кб имеют размер 256 байт разделенные на 16 блоков где trail - шестнадцатый блок.

+==========+===============+
| Sector 0 | Block 0       |
| 		   | Block 1       |
| 		   | Block 2       |
| 		   | Block 3 trail |
+----------+---------------+
| Sector 1 | Block 4       |
| 		   | Block 5       |
| 		   | Block 6       |
| 		   | Block 7 trail |
+----------+---------------+
| Sector 2 | Block 0       |
| 		   | Block 1       |
| 		   | ...           |
+----------+---------------+

Сектор 0 содержит системную информацию и запись в него может привести к порче метки.
Сектор 1 может использоваться для хранения CIS индексов, что это такое я не понял, но думаю, что трогать сектор 1 не стоит.

Блок доступа trail имеет следующий формат [AAAAAAxxx0BBBBBB]

Байты 0..6 - ключ A
Байты 7..9 - биты доступа
Байт 10 - не используется (данные пользователя)
Байты 11 - 15 - ключ B

(Калькулятор бита доступа)[http://calc.gmss.ru/Mifare1k/]
